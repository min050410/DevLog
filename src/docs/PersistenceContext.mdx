# 영속성 컨텍스트 - 엔티티의 생명주기

이번 블로그에서는 spring을 공부하며 가장 중요한 엔티티의 생명주기에 관해 블로그를 써보고자 합니다.  
엔티티의 생명 주기가 무엇인지 먼저 알아보고 영속성 컨텍스트와 엔티티 생명주기의 상관관계,  
더티체킹과 엔티티 매니저 등 여러 개념들을 다루고자 합니다.

### 1-1. 영속성 컨텍스트란?
엔티티를 영구적으로 저장할 수 있는 환경입니다. 스프링부트 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 DB같은 공간입니다.
엔티티가 실제 DB에 반영되기전 거치는 캐시라고 생각해도 됩니다.

### 1-2. JPA는 영속성 컨텍스트를 왜 사용하는가?
<big>1차 캐시</big>   
영속성 컨텍스트 내부에는 캐시가 있는데 이를 1차 캐시라고 부릅니다.  
캐시는 Map의 형태로 만들어져 엔티티가 저장됩니다.  

```js
key: @Id로 선언한 필드, 데이터베이스의 기본키와 매핑  
value: 엔티티 인스턴스
```

em.find()를 통해 엔티티를 호출하면 먼저 1차 캐시에 있는지 찾고 <big>없다면 DB에서 조회한 뒤 1차 캐시에 저장됩니다.</big> 
다음에 또 호출하게 되면 DB에서 호출할 필요 없이 1차 캐시에서 바로 찾을 수 있습니다.

<big>동일성 보장</big>  
DB에서 조회한 엔티티로 새로 생성하는게 아닌 1차 캐시에서 엔티티를 불러오므로 동일성 보장이 됩니다.
```js
User findUser1 = em.find(User.class, "user1");
User findUser2 = em.find(User.class, "user2");
System.out.println(findUser1 == findUser2); // true
```

<big>쓰기 지연</big>  
트랜젝션을 지원하는 쓰기 지연이 가능합니다.  
영속성 컨텍스트 내부에 있는 쓰기 지연 저장소에서 쿼리문을 따로 저장하는데
트랜잭션 커밋을 실행할 때 미리 저장해 두었던 SQL문을 한번에 실행하므로 쓰기 지연을 지원합니다.

### 1-3. 너 영속 상태가 되어라
엔티티 매니저(Entity Manager, em)를 통해 엔티티를 영속화 시킬 수 있고 실제 DB에 반영할 수 있습니다.  
엔티티를 영속화 시킨다는 말은 엔티티를 영속성 컨텍스트에서 관리한다는 뜻입니다.  

일반 엔티티 객체를 영속성 컨텍스트에 등록하려면 em.persist()를 하여야 합니다.  

<big>또 일반 엔티티를 조회하려고 하면 영속 상태가 됩니다.</big>  
em.find()로 조회하게 되면 먼저 영속성 컨텍스트 내부 1차 캐시에서 한번 찾고 없으면 DB에서 불러와 해당 엔티티를 1차 캐시에 저장합니다.  
그렇기 때문에 영속성 컨텍스트에서 관리하는 영속 상태가 되는 것입니다.  
마찬가지로 JpaRepository로 엔티티를 조회하게 되면 식별자를 인자로 받아 내부적으로 em.find()를 호출해 해당 엔티티가 영속화 됩니다.

### 1-4. 영속성 컨텍스트의 특징
- 엔티티를 식별자 값으로 구분합니다. 식별자 값이 반드시 있어야 합니다.
- 데이터베이스 저장시 트랜젝션을 커밋하게 되면 영속성 컨텍스트의 저장된 엔티티와 변경된 엔티티를 감지해 데이터베이스에 반영합니다.
- 엔티티 매니저는 트랜젝션을 커밋하기 직전까지 SQL 쿼리를 모아둡니다. 모아두는 공간을 쓰기 지연 저장소라고 합니다.
- 영속성 컨텍스트에 포함되었다고 해서 실제 DB에 반영된 것은 아니고 엔티티 매니저에서 flush를 하여야만 실제 DB에 반영됩니다.

### 2-1. 엔티티의 생명주기란?

<img src="https://github.com/min050410/min050410/assets/45661217/a6798d08-8995-484d-814b-11566b288ff6" width="70%"></img>
프론트를 하신 분이라면 혹시 리액트의 생명주기를 알고 계시나요.  
리액트에서 Mount 되었다가 엔티티의 생명주기에서는 영속성 컨텍스트에 포함되었다로 표현할 수 있겠습니다.  
하지만 JPA에는 Detached라는 새로운 상태가 있습니다. 우선 엔티티의 4가지 상태를 알아봅시다. 

<big>1. 비영속 상태(new, transient)</big>

-> 순수한 객체 상태로 영속성 컨텍스트와 관련이 없는 상태입니다.  
이 객체가 변경이 되더라도 나중에 DB에 반영이 절대 되지 않습니다.  

비영속 상태를 코드로 표현하면 다음과 같습니다.  
```js
Member member = new Member();
```
엔티티 객체를 new를 이용해 생성시 아직 영속성 컨텍스트에 포함되지 않는 비영속 상태가 됩니다.

<big>2. 영속 상태(managed)</big>

-> 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한 상태입니다.  
영속성 컨텐츠가 해당 엔티티를 관리하는 상태입니다.

persist()를 실행하게 되면 영속 상태가 되어 영속성 컨텍스트에 포함됩니다.
```js
em.persist(member);
```

<big>3. 준영속 상태(detached)</big>

-> 엔티티를 영속성 컨텍스트에서 잠깐 삭제한 상태를 말합니다.
detach()를 하거나 clear를 실행하면 준영속 상태가 됩니다.   

준영속 상태일 경우 비영속 상태와 비슷합니다. 하지만 준영속 상태는 <big>식별자를 보유하고 있다는 점에서 차이가 있습니다.</big>
```js
// 엔티티를 영속성 컨텍스트에서 분리해 준영속 상태로 만듭니다.
em.detach(member);
// 영속성 콘텍스트를 비워도 관리되던 엔티티는 준영속 상태가 됩니다.
em.claer();
```
merge()를 실행하면 다시 영속 상태로 변경할 수 있습니다.
```js
em.merge(member);
```

<big>4. 삭제(removed)</big>

-> 엔티티를 영속성 컨텍스트와 db에서 삭제한 상태입니다.
```js
// 삭제
em.remove(member);
```

<big>5. 반영(flush)</big> 

em.flush()를 실행하면 Entity와 스냅샷의 다른 점을 찾아 실제 DB에 반영합니다.

```js 
em.flush()
```

> 스냅샷이란?  
처음 엔티티가 1차 캐시에 들어오면 스냅샷을 찍어 저장하고  
DB에 반영되는 시점에서는 변경된 엔티티와 비교합니다.

### 2-2. 헷갈리는 개념들
<img src="https://github.com/min050410/min050410/assets/45661217/d7a1b698-7427-4159-a787-ab7e4625c0ef" width="70%"></img>

자 정리를 해봅시다.  
영속성 컨텍스트 안에는 1차 캐시와 쓰기 지연 저장소가 들어있습니다.   
1차 캐시에는 다음과 같은 컬럼들이 있습니다.  

<big>@Id, Entity, 스냅샷</big>  
@Id 컬럼에서는 Entity의 식별자와 매핑한 값이 들어갑니다.  
Entity 칼럼에서는 Entity의 실체가 들어갑니다.  
스냅샷 칼럼에는 영속성 컨텍스트 1차 캐시에 처음 포함된 엔티티가 저장됩니다.

추가로 영속성 컨텍스트에는 쓰기지연 저장소가 존재합니다.  
쓰기지연 저장소에서는 SQL문을 저장하고 트랜젝션이 커밋될 시 한번에 쿼리를 실행합니다.

### 2-3. 더티 체킹의 개념
앞서 트랜잭션이 커밋될시 스냅샷과 변경된 엔티티를 비교해 다른 부분이 있다면 실제 DB에 반영한다고 설명했습니다.  
이 개념을 더티 체킹이라고 합니다.
save 메소드로 저장하지 않아도 엔티티의 상태 변화로 실제 DB에 반영되는 것입니다.

### 2-4. 실제 예제로 확인하기
```js
/**
 * 레시피 업데이트
 */
@Transactional
public void updateRecipe(Recipe recipe, ExtractedRecipeResponseDto response) {
    recipe.updateIsSelected();
    recipe.update(response.toIngredientItems(),
        response.toSeasoningItems(),
        response.toProcedureItems());
}
```
위 코드는 레시피 엔티티를 업데이트 해주는 코드입니다. 
여기서 파라미터로 들어온 recipe는 repository.findById()를 통해 불러와 영속화된 엔티티입니다.
@Transactional 어노테이션이 메서드에 적용되어 있기 때문에 해당 메서드는 트랜잭션 범위 내에서 실행됩니다.  
recipe.update()를 실행해 레시피 엔티티의 상태를 변경합니다.
이후 트랜잭션이 커밋되는 시점에 레시피 엔티티의 변경점을 실제 데이터베이스에 반영합니다.

### 3. 마무리
영속성 컨텍스트와 엔티티의 생명 주기를 배우며 "이게 왜 이 코드가 실제 DB 반영 됨?"하는 궁금증이 많이 해소된 것 같습니다.   
앞으로 엔티티의 상태를 생각하며 깔끔하게 코드를 짜봐야겠다는 생각을 하였습니다. 

### 레퍼런스
[JPA-영속성-컨텍스트란](https://velog.io/@neptunes032/JPA-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80)  
[더티 체킹 (Dirty Checking)이란?](https://jojoldu.tistory.com/415)  
[Entity Lifecycle을 고려해 코드를 작성하자 1편](https://tecoble.techcourse.co.kr/post/2020-08-31-entity-lifecycle-1/)