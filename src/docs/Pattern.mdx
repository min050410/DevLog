# 자바에 나오는 모든 디자인 패턴정리

## 목차
- flyweight 패턴 (웨이트급 공유)
- singleton 패턴 (인스턴스는 하나면 충분해)
- proxy 패턴 (엔티티)
- Composite 패턴 (상속보단조합상속보단조합)

## 1. flyweight 패턴
인스턴스를 <big>가능한대로</big> 공유시켜서 쓸데없는 new 연산자를 통한 메모리 낭비를 줄이는 방식입니다.  
<big>식당(Factory)</big>에서 <big>요리(instance)를</big> 최대한 많이 공유하도록 설계된 패턴이라고 보시면 됩니다. 

패턴을 자세히 알아보겠습니다.

- <big>flyweight(플라이급)</big>
1. 공유에 사용할 클래스들의 API를 선언합니다.

- <big>ConcreteFlyweight(구체적인 플라이급)</big>
2. flyweight 내용을 정의합니다.

- <big>flyweightFactory</big>
3. Flyweight의 인스턴스를 생성하고 공유하는 역할을 합니다. 

### 1-1. 플라이웨이트 패턴 구현하기

Flyweight

```js
public interface Shape {
    public void draw();
}
``` 

ConcreteFlyweight
```js
public class Circle implements Shape {
    private String color;
    private int x;
    private int y;
    private int radius;

    public Circle(String color) {
        this.color = color;
    }

    @Override
    public void draw() {
        System.out.println("Circle [color=" + color + ", x=" + x + ", y=" + y + ", radius=" + radius + "]");
    }
}
```

flyweightFactory
```js
public class ShapeFactory {
    private static final HashMap<String, Circle> circleMap = new HashMap<>();

    public static Shape getCircle(String color) {
        Circle circle = (Circle)circleMap.get(color);
        // 만약 해당 색갈의 circle이 없다면 new를 이용해 객체 생성
        if(circle == null) {
            circle = new Circle(color);
            circleMap.put(color,circle);
            System.out.println("==== 새로운 객체 생성 : " + color + "색 원 ====" );
        } 
        // 기존 객체 재사용
        return circle;
    }
}

```

<big>if 부분</big>이 flyweight 패턴의 핵심입니다.  
circle을 색으로 얻는데 만약에 해당 색의 circle이 있으면 그 값으로 리턴해주고 없으면 new를 이용해 새로 생성합니다.  
같은 색이 있다면 그 같은 색의 인스턴스를 굳이 다시 만들 필요가 없겠죠?  
<big>if 문을 통해 기존 객체가 재사용되고 이는 메모리 낭비를 줄일 수 있습니다.</big>

### 1-2. 사용되는 이유
- 여러 가상 객체의 상태를 한 쪽으로 집중해서 넣을 수 있습니다.  
- 실행시에 객체 인스턴스의 개수를 줄여 메모리를 절약할 수 있습니다.  
-> <big>최대한 새로 생성되는 인스턴스를 줄이는</big> 플라이웨이트 패턴의 장점입니다.

### 1-3. 단점
- 특정 인스턴스만 다른 인스턴스처럼 사용하는 것이 불가능합니다. (커스텀 불가능)  
-> 모든 구현체는 <big>ConcereteFlyweight</big>에 담겨있기 때문입니다.

## 2. Singleton 패턴
싱글톤 패턴은 <big>인스턴스를 하나만 생성할 수 있는 패턴</big>을 의미합니다.  
여러차례 호출되어도 처음 생성한 객체인 1개를 리턴해주는 패턴입니다.  
싱글톤으로 만들 수 있는 객체는 설계상 유일해야 하는 시스템 컴포넌트를 예로 들 수 있습니다.

- singleton
1. 유일한 인스턴스를 얻기 위해 static 메소드를 가집니다.

### 2-1. 근데 왜 static을 쓰죠?

: 메모리 이점  
변수에 static을 붙이면 자바는 메모리 할당을 한번만 하게 되어 메모리 사용에 이점이 있습니다.  
이를 통해 나온 것이 바로 싱글톤 패턴! 

: 공유  
static을 사용하면 같은 메모리 주소를 보기 때문에 static 변수의 값을 공유하게 됩니다.  

### 2-2. 싱글톤패턴 구현하기

public static으로 인스턴스 생성 방식
```js
public class Elvis {
		public static final Elvis INSTANCE = new Elvis();
		private Elvis() { ... }
		
		public void leaveTheBuilding() {
				...
		}
}
```

정적 팩토리 메서드를 활용하는 방식
```js
public class Elvis {
		private static final Elvis INSTANCE = new Elvis();
		private Elvis() { ... }
		
		public static Elvis getInstance() {
				return INSTANCE;
		}

		public void leaveTheBuilding() {
				...
		}
}
```
싱글톤이 아니라 다른 방식으로 변환하고 싶을 때 

### 부록1. 이펙티브 자바 ITEM3. 싱글톤 생성 방식도 최적화
Lazy Initialization
객체 사용시점에 생성하는 방식이다. 그러나 getInstance에 두 개 이상의 스레드가 동시 접근 하였을 때 2개 이상의 객체가 2개 생길 수 있다는 문제점이 있어, synchronized 블록으로 lock을 거는 방식이다.

```js
public class SyncSingleton {
	private static SyncSingleton instance;

	private SyncSingleton() {
		System.out.println("Constructor");
	}

	public static  SyncSingleton getInstance() {
		if(instance==null) {
			synchronized (SyncSingleton.class) {
				if(instance==null) {
					instance = new SyncSingleton();
				}
			}
		}

		return instance;
	}

	public void print() {
		System.out.println("SyncSingleton instance Hash : " + instance.hashCode());
	}
}
```

Lazy Holder
Lazy Initialization에서 thread safe하려면 코드가 꼴보기 싫어진다. 원리 상 큰 차이는 없지만 thread safe하게 가져가는 트릭으로 Lazy Holder가 있다.

```js
public class Singleton {

	private Singleton() {
		System.out.println("Constructor");
	}

	private static class LazyHolder {
		private static final Singleton INSTANCE = new Singleton();
	}

	public static Singleton getInstance() {
		return LazyHolder.INSTANCE;
	}

	public void print() {
		System.out.println("Singleton instance Hash : " + LazyHolder.INSTANCE.hashCode());
	}
}
```

### 2-3. 싱글톤의 장점

### 2-4. 싱글톤의 단점
- private 생성자를 가지고 있기 때문에 상속할 수 없다.

