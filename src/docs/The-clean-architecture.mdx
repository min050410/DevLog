# 클린 아키텍처에 대해 알아보자

### 시작에 앞서

최근에 소프트웨어 구조에 관심이 많아져 찾아보다 클린 아키텍처라는 것을 알게 되었습니다.  
워낙 잘 알려진 개념이라 틀리지 않는것에 주의하며 블로그를 써보려 합니다.  

### 클린 아키텍처란?

![클린아키텍처](http://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg)

사진 출처 : [http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html](http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

클린 아키텍처는 “클린 코드”의 저자 로버트 C. 마틴이 제안한 아키텍처입니다.  
위에 보이는 것이 유명한 클린 아키텍처의 동심원입니다. 클린 아키텍처는 의존성(dependency)에 초점을 맞추고 있습니다.  
화살표 방향은 의존성 규칙이 향하는 방향입니다. 
내부 원 안의 어떤것도 외부 원에 대해서 알 수 없고,  
외부 원에 있는 어떤 것도 내부 원들에 영향을 미치기를 원하지 않습니다. 

외부 원을 저수준, 내부원을 고수준이라고 부릅니다.

> 고수준 - 원의 안쪽, 추상화된 개념  
> 저수준 - 원의 바깥쪽 안쪽의 추상화된 개념을 어떻게 구현할지에 대한 개념

의존성 규칙에 대해 더 알아보기 전에 사진에 나오는 용어를 알아보도록 하겠습니다.

> Entity  
실제, 객체라는 의미로 업무에 필요하고 유용한 정보를 저장하고 관리하기 위한
집합적인 것이다.

> UseCase   
비즈니스 규칙 정의

<br/> 

> Controller  
애플리케이션 API 엔드포인트

> Gateway  
API 게이트웨이는 실제 백엔드 서비스 또는 데이터와 접속하고 API 호출에 대한 정책,   
인증 및 일반 액세스 제어를 적용하여 중요한 데이터를 보호하는 트래픽 관리자이다. 

> Presenter  
Container에서 처리한 상태를 props로 전달받아 상태를 화면에 출력하는 컴포넌트.  
주로 Container - Presenter 패턴을 사용하는 react에서 주로 쓰인다.

### 클린 아키텍처의 핵심

사진에서 원의 가장 밖에 있는 framework로 구현한 UI는 내부 Controllers에 대해 잘 알고 있어야 합니다.  
게시판을 불러오는 경우를 생각해봅시다. 게시판은 게시판 api를 불러와야 합니다.  
framework로 구현한 UI는 Controller의 구조가 바뀜에 따라 코드 구현이 달라집니다.  
따라서 UI는 Controller에게 의존성이 있다고 말할 수 있습니다.  

하지만 Controller의 경우는 어떻게 될까요?  
Controller는 UI나 WEB같이 구체적인 세부 사항에 의존하지 않아야 합니다. 

마찬가지로, 가장 안에 있는 Entity는 Controller에 대해서 알지 못해야 하고, Controller는 UseCase를 잘 알고 있어야 합니다. 
이것이 클린 아키텍처의 핵심입니다.

### 왜 클린 아키텍처를 고집할까?

디펜던시 규칙을 준수함으로써, 데이터베이스나 웹 프레임워크나 같은 외부 부분들이 쓸모없게 될 때, 
그러한 쓸모없는 요소들을 최소한으로 대체할 수 있습니다. 왜냐하면 내부 요소들은 외부 부분들에게 의존성이 없기 때문입니다.

더 생각해봅시다. 내가 만약에 웹 프레임워크로 댓글 기능을 구현하고 있는데 쓸모가 없어졌습니다.  
하지만 내부 요소들에게 의존성이 있다면 내부 요소들까지 싹 다 고처야 될 것입니다. 고치다 내부 요소에서 에러가 발생하면  
정상적인 서비스를 할 수 없게 됩니다. 시간도 오래걸릴 것이구요.

이해를 돕기 위해 다른 예시를 설명하겠습니다. 
UseCase인 한 클래스는 어떤 DB를 사용하는지 모릅니다. 그렇기 때문에 나중에 DB를 변경하거나 확장해도 전혀 문제가 되지 않는 것입니다.
아키텍처를 설계할 때 DB에 대한 선택을 최후로 미룰 수 있다는 뜻입니다. 우리는 DB를 선택하고 만약 내부에서 어떤 문제가 생기면 내부 로직에는 변함없이 DB만 변경하면 되는 아키텍처를 설계할 수 있습니다. 

### 클린 아키텍처의 기본이 되는 SOLID에 대해 알아봅시다

클린 아키텍처의 바탕에는 객체 지향 설계 원칙(SOLID)가 깔려 있습니다.  
[SOLID](http://blog.cleancoder.com/uncle-bob/2020/10/18/Solid-Relevance.html)는 로버트 C. 마틴이 객체 지향 언어로 소프트웨어를 설계할 때의 방법론을 체계적으로 정리한 것입니다.

> SRP - 단일 책임 원칙  
> 한 클래스는 하나의 책임만 가져야 한다.

여기서 클래스는 여러 객체지향 언어에서 말하는 그 클래스 자체를 의미하는 것이 아니라 함수, 오브젝트 등 최소 동작의 단위가 되는 개념을 말합니다.
코드를 작성하다보면 한 클래스에 기능이 여러개 들어있어 점점 커지는 경우가 있습니다.  
따라서 클래스를 크기가 작고 작은 책임을 가지도록 작성해야 변경에 유연하게 대처할 수 있습니다. 

> OCP - 개방-폐쇄 원칙  
> 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다. 

기능의 추가가 기존 코드에 영향을 끼치지 않도록 해야 합니다. 
필요한 기능이 있다면 그 구현체에 의존하지 않고 인터페이스에 의존하도록 해야 합니다. 

> LSP - 리스코프 치환 원칙  
> 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

실제 동작하는 인스턴스는 인터페이스가 제공하는 기능을 구현한 객체이지만 인터페이스를 사용하는 다른 객체에 전달할 수 있습니다. 따라서 실제 구현체인 자식 인스턴스는 언제든지 부모 또는 인터페이스가 제공해야 하는 기능을 제공하는 다른 구현체로 바꿀 수 있습니다.

> ISP - 인터페이스 분리 원칙  
> 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.

하나의 인터페이스에 의존하게 되면 인터페이스에 기능이 추가될 때 인터페이스를 구현하는 모든 클래스를 수정해야 합니다. 이렇게 하기 보다는 인터페이스를 기능별로 잘게 쪼개어 특정 클라이언트용 인터페이스로 모아 사용하는 것이 변경에 대해 의존성을 낮추고 유연하게 대처할 수 있는 방법입니다.

> DIP - 의존성 역전 원칙  
> 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다

클린 아키텍처를 구현하기 위해서는 의존성 역전이 발생하기 마련이고 이를 해소하기 위해 의존성 주입(DI)를 이용해야 합니다.
의존성 주입은 보통 프레임워크에서 제공하거나 DI를 구현할 수 있는 라이브러리를 이용합니다.

SOLID의 개념에 대해 알아보았습니다.  

### 마치며

`nest.js` 프로젝트를 진행하고 있는데 생각이 많아졌습니다. 클린 아키텍처를 보며 `nest.js`는 클린 아키텍처가 기본적으로
설계 되어져 있다고 생각이 들었습니다. DI도 구현되어 있고, 컨트롤러 모듈 서비스 등이 각각 나눠져 있기 때문에  
의존성이 낮지 않을까 라는 생각을 해봅니다. 하지만 완전한 클린 아키텍처가 아니기 때문에 레이어를 나누는 과정이 필요할 것 같습니다.
또, 클린 아키텍처를 달성하기 위해 끊임없는 리팩토링을 해야할 것입니다.
클린 아키텍처를 이용해 4개의 레이어를 정의하고 리팩토링 하는 과정을 분명 힘들겠지만
가치 있을 것이라고 생각합니다. 다음에 가능하다면 클린 아키텍처를 실제로 코드에 적용해보고 후기로 돌아오겠습니다. 








 





