# 비선형 구조 정리
**C** **tree** **graph**

### 비선형 구조란?
비선형 구조는 `일대일`로 연결되어 있지 않고, `일대다` 또는 `다대다`의 관계를 맺는 구조를 형성하는 구조이다.

### 목차
- 트리
- 그래프 

## 트리
**노드(Node)** **간선(Edge)**

<img src="https://user-images.githubusercontent.com/45661217/146921717-ee3ac922-9a3a-4519-bf47-a447c98e5404.png" width="100%"></img>

### 트리란?  
각각의 자료들을 계층적으로 서로 연결한 자료구조이다.
`포함 관계` 혹은 `상 하위 관계`를 표현할 때 사용된다.

가장 상위에 있는 노드를 `최상위(root)` 노드라고 하며
자식 노드와 연결된 간선의 개수가 `0`개인 노드를 `단말(Leaf)` 노드라고 한다.

트리의 용어를 더 자세히 알아보자.  

<img src="https://user-images.githubusercontent.com/45661217/146921809-8c27ba8e-25d7-489e-b52c-e390ee361fa0.png" width="100%"></img>

### 형제 노드
같은 부모를 가지는 노드를 말한다.   
### 노드의 깊이
`depth`는 중요한 개념이다.   
`root`에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수를 뜻한다.    
### 노드의 레벨 
`level`은 트리의 특정 깊이를 가지는 노드의 집합을 말한다.  
다음 트리를 봤을 때 각 `level` 마다 노드의 집합이 달라지는 것을 알 수 있다 
```text
level 1             1
level 2           2   3
level 3         4   5   6
level 4       7       8   9
 ```
### 노드의 차수 
`degree`는 각 노드가 지닌 가지의 수를 뜻한다  
### 트리의 높이
`height`는 루트 노드에서 가장 깊숙히 있는 노드의 깊이이다.  
### 트리의 차수
`degree of tree`는 트리의 `최대 차수`이다.    

`트리의 차수`는 `최대 차수`를 통해서 구할 수 있다.  예를 들면  
```text
     10
    /  \
   4   14
  / \
 2   6
```
만약 위와 같은 트리가 있다면 차수는 `2`이다.  
하지만 만약 하나의 노드가 자식이 `3`개 있다면 최대 차수가 `3`이 되므로 그 트리는 차수가 `3`이 된다.
## 이진 트리
### 이진 트리의 개념

<img src="https://user-images.githubusercontent.com/45661217/146921745-96f811bd-7ee1-4201-95b7-ecc674a6fadb.png" width="70%"></img>

다음 그림과 같이 모든 노드의 차수가 `2 이하인 트리`를 `이진 트리` 라고 한다.  

### 이진 트리의 성질  
이진 트리에서 노드의 개수를 `n`개로 정의하였을 때, 간선의 개수는 항상 `n-1`개를 가진다.  
또, 높이가 `h`일때 노드의 최소 개수는 `h`개 이며, 최대 개수는 `2^h-1`개로 정의 할 수 있다.  

### 이진 트리의 종류

#### 포화 이진 트리

모든 레벨에 노드가 완전히 찬 트리를 `포화 이진 트리`라고 한다.  
포화 이진 트리에서 최대 레벨 수를 `k`라고 한다면 전체 노드의 수는 `2^k-1`로 쉽게 구할 수 있다
```text
// 포화 이진 트리

      10   
    /    \
   4      14
  / \    /  \
 2   6  5    7
```

#### 완전 이진 트리

높이가 `h`인 트리에서 레벨 `h-1`까지 모든 노드가 채워져 있고 마지막 레벨에서는 노드가 왼쪽에서 오른쪽으로
저장된 구조를 `완전 이진 트리`라고 한다.  

```text
// 완전 이진 트리

      10   
    /    \
   4      14
  / \      
 2   6      
```
> 모든 포화 이진트리는 완전 이진 트리이다

#### 편향 이진 트리

각 노드가 왼쪽 혹은 오른쪽으로 치우쳐 있는 구조를 `편향 이진 트리`라고 한다.  
```text
// 편향 이진 트리

     10
    /  
   4   
  / 
 2   
```

### 이진 트리의 순회

이진 트리를 출력할 때나 값을 읽을 때 한번씩 차례대로 방문해야한다.  
이진 트리를 방문하는 방법으로는 세가지 방법이 있다.

```text
      10   
    /    \
   4      14
  / \    /  \
 2   6  5    7
```
#### 전위 순회

`root`노드 -> 왼쪽 서브 트리 -> 오른쪽 서브 트리 순서  
10 -> 4 -> 2 -> 6 -> 14 -> 5 -> 7  

#### 중위 순회

왼쪽 서브 트리 -> `root`노드 -> 오른쪽 서브 트리 순서  
10 -> 4 -> 2 -> 6 -> 14 -> 5 -> 7  

#### 후위 순회

왼쪽 서브 트리 -> 오른쪽 서브 트리 -> `root`노드 순서  
10 -> 4 -> 2 -> 6 -> 14 -> 5 -> 7  

### 트리의 구현

#### 배열을 이용한 트리의 구현

```c
#include<stdio.h>

// 전위 순회
// 전달인자로 tree, index, 트리의 size를 갖는다
void preorder( char *t, int n, int size ){
	if(n>size||t[n]==0) return ;
	printf("%c ", t[n]);
	preorder(t, 2*n, size);
	preorder(t, 2*n+1, size);
}

int main(){
	//비어있는 곳은 0이라는 숫자를 넣음
	char tree[]= { 0,'A', 'B', 'C', 'D', 'E', 'F', 'G', 0, 0,'H', 'I', 0, 'J', 'K', 'L'};
	int size=16;
	printf("\n<<전위 탐색>>\n");
	preorder( tree, 1, size );
	printf("\n<<중위 탐색>>\n");
	inorder( tree, 1, size );
	printf("\n<<후위 탐색>>\n");
    postorder( tree, 1, size );
}
```
배열을 이용한 트리의 구현은 간단하다

```text
      1  
    /   \
   2     3
  / \   /  \
 4   5 6    7
```
트리의 `index`가 이렇게 있다면 왼쪽 아래 노드의 `index`는 `index*2` 오른쪽 아래는 `index*2+1`로 접근할 수 있다.    
위의 코드는 규칙을 이용해 `재귀 함수`로 트리 배열을 출력한 모습이다.   

#### 연결 리스트를 활용한 트리의 구현

![image](https://iq.opengenus.org/content/images/2021/06/1.png)

하나의 노드는 왼쪽 서브 트리의 주소를 갖는 `left`   
오른쪽 서브 트리의 주소를 갖는 `right`가 존재하고 `data`로 노드의 값을 갖는다


```c
typedef struct treeNode{
	char data;
	struct treeNode *left;
	struct treeNode *right;
} treeNode;
```
노드의 구조는 이런 형식으로 구성된다

### 블로그를 마치며,
트리 자료구조는 `AI`에도 쓰는 만큼 아주 중요한 개념이며  
개발자라면 확실히 알고 가야 될 자료구조이다!

> 그래프 추후 업로드